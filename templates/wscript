#!/usr/bin/python3


import os
import functools


APPNAME = 'XeLaTeX project'
VERSION = '0.1'


top = '.'                               # Project root directory.
out = os.path.join(top, 'build')        # Project output directory.


def _get_project_config(env):
    """ Returns project configuration as Python dict.
    """
    with open(os.path.join(env.TOOLS_DIR, 'defaults', 'config.py')) as fp:
        config = eval(fp.read())
    try:
        file = open(env.CONFIG_FILE)
    except IOError:
        pass
    else:
        config.update(eval(file.read()))
    return config


def _render_templates(path, templates_names, context):
    """ Renders template using Jinja2 template engine.
    """
    from jinja2 import Environment, FileSystemLoader, exceptions
    env = Environment(
            block_start_string='<' + '|',
            block_end_string='|' + '>',
            variable_start_string='<' + '<',
            variable_end_string='>' + '>',
            comment_start_string='<' + '#',
            comment_end_string='#' + '>',
            loader=FileSystemLoader(path),
            )
    results = []
    for template_name in templates_names:
        try:
            template = env.get_template(template_name)
        except exceptions.TemplateSyntaxError as e:
            print('{0.filename} ({0.name}):{0.lineno} {0.message}'.format(
                e))
            raise
        results.append(template.render(context))
    return results


def _render_task(task):
    """ Renders task templates.
    """
    path = [
            os.path.join(task.generator.env.CONFIG_DIR, 'templates'),
            os.path.join(task.generator.env.TOOLS_DIR, 'templates'),
            ]
    templates_names = [output.name for output in task.outputs]
    results = _render_templates(
            path, templates_names,
            dict(task.generator.env,
                **_get_project_config(task.generator.env)),
            )
    for output, result in zip(task.outputs, results):
        print(output.name, output.abspath())
        output.abspath()
        with open(output.abspath(), 'w') as outfile:
            outfile.write(result)


def _concat_task(task):
    """ Renders and concats to single file.
    """
    path = [
            os.path.join(task.generator.env.CONFIG_DIR, 'templates'),
            os.path.join(task.generator.env.TOOLS_DIR, 'templates'),
            ]
    target_template = task.outputs[0].name
    # FIXME: templates_names = [inpt.name for inpt in task.inputs]
    config = _get_project_config(task.generator.env)
    templates_names = config['concat_files'][target_template]
    context = dict(task.generator.env, **config)
    results = zip(
            templates_names,
            _render_templates(path, templates_names, context,))
    context['rendered_parts'] = results
    result = _render_templates(path, (target_template,), context)[0]
    with open(task.outputs[0].abspath(), 'w') as outfile:
        outfile.write(result)


def configure(ctx):
    """ Sets configuration.
    """
    ctx.load('tex')
<< configuration >>


def _get_template_path(ctx, file_name):
    """ Returns path to template file to depend on.
    """
    user_path = os.path.join(ctx.env.CONFIG_DIR, 'templates', file_name)
    default_path = os.path.join(ctx.env.TOOLS_DIR, 'templates', file_name)
    if os.path.exists(user_path):
        return user_path
    else:
        return default_path


def build(ctx):
    ctx.load('tex')
    bld = functools.partial(ctx, update_outputs=True)
    glob = ctx.path.ant_glob
    config = _get_project_config(ctx.env)

    bld(
            rule=_render_task,
            source=(
                glob(os.path.join(ctx.env.CONFIG_DIR, 'templates', '*')) +
                glob(os.path.join(ctx.env.TOOLS_DIR, 'templates', '*'))),
            target=config['template_files'])

    for target, sources in config['concat_files'].items():
        files = [_get_template_path(ctx, source) for source in sources]
        files.append(
                os.path.join(ctx.env.TOOLS_DIR, 'defaults', 'config.py'))
        if os.path.exists(ctx.env.CONFIG_FILE):
            files.append(ctx.env.CONFIG_FILE)
        bld(rule=_concat_task, source=files, target=target)

                #'\\\\newcommand{\\docVersionHash}{'
                #'$(git log -1 --pretty=format:"%%H")}'
                #'\\\\newcommand{\\docVersionTime}{'
                #'$(git log -1 --pretty=format:"%%ai")}'
    xelatex = (
                '${XELATEX} '
                '-interaction=batchmode '
                '-shell-escape '
                '-jobname=document '
                '\"'
                '\\input{main.tex}'
                '\"'
                )
    biber = '${BIBER} document'
    bld(
            rule=xelatex,
            #source=(
                #glob(os.path.join(out, '*.tex')) +
                #glob(os.path.join(out, '*.sty')) +
                #glob(os.path.join(out, '*.cls')) +
                #glob(os.path.join(ctx.env.CONTENT_DIR, '*'))
                #),
            target='document.pdf',
            name='xelatex1',
            always=True,
            )
    bld(
            rule=xelatex,
            #source=(
                #glob(os.path.join(out, '*.tex')) +
                #glob(os.path.join(out, '*.sty')) +
                #glob(os.path.join(out, '*.cls')) +
                #glob(os.path.join(ctx.env.CONTENT_DIR, '*'))
                #),
            target='document.pdf',
            name='xelatex2',
            after='xelatex1',
            always=True,
            )
    if config['use_bibliography']:
        bld(
                rule=biber,
                name='biber',
                before='xelatex2',
                after='xelatex1',
                always=True,
                )
