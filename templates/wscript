#!/usr/bin/python3


import os
import functools


APPNAME = 'XeLaTeX project'
VERSION = '0.1'


top = '.'                               # Project root directory.
out = os.path.join(top, 'build')        # Project output directory.


def _get_project_config(env):
    """ Returns project configuration as Python dict.
    """
    with open(os.path.join(env.TOOLS_DIR, 'defaults', 'config.py')) as fp:
        config = eval(fp.read())
    try:
        file = open(env.CONFIG_FILE)
    except IOError:
        pass
    else:
        config.update(eval(file.read()))
    return config


def _render_templates(path, templates_names, context):
    """ Renders template using Jinja2 template engine.
    """
    from jinja2 import Environment, FileSystemLoader, exceptions
    env = Environment(
            block_start_string='<' + '|',
            block_end_string='|' + '>',
            variable_start_string='<' + '<',
            variable_end_string='>' + '>',
            comment_start_string='<' + '#',
            comment_end_string='#' + '>',
            loader=FileSystemLoader(path),
            )
    results = []
    for template_name in templates_names:
        try:
            template = env.get_template(template_name)
        except exceptions.TemplateSyntaxError as e:
            print('{0.filename} ({0.name}):{0.lineno} {0.message}'.format(
                e))
            raise
        results.append(template.render(context))
    return results


def _render_task(task):
    """ Renders task templates.
    """
    path = [
            os.path.join(task.generator.env.CONFIG_DIR, 'templates'),
            os.path.join(task.generator.env.TOOLS_DIR, 'templates'),
            ]
    templates_names = [output.name for output in task.outputs]
    results = _render_templates(
            path, templates_names,
            dict(task.generator.env,
                **_get_project_config(task.generator.env)),
            )
    for output, result in zip(task.outputs, results):
        print(output.name, output.abspath())
        output.abspath()
        with open(output.abspath(), 'w') as outfile:
            outfile.write(result)


def _concat_task(task):
    """ Renders and concats to single file.
    """
    path = [
            os.path.join(task.generator.env.CONFIG_DIR, 'templates'),
            os.path.join(task.generator.env.TOOLS_DIR, 'templates'),
            ]
    target_template = task.outputs[0].name
    # FIXME: templates_names = [inpt.name for inpt in task.inputs]
    config = _get_project_config(task.generator.env)
    templates_names = config['concat_files'][target_template]
    context = dict(task.generator.env, **config)
    results = zip(
            templates_names,
            _render_templates(path, templates_names, context,))
    context['rendered_parts'] = results
    result = _render_templates(path, (target_template,), context)[0]
    with open(task.outputs[0].abspath(), 'w') as outfile:
        outfile.write(result)


def configure(ctx):
    """ Sets configuration.
    """
<< configuration >>


def build(ctx):
    bld = functools.partial(ctx, update_outputs=True)
    config = _get_project_config(ctx.env)
    bld(rule=_render_task, target=config['template_files'], always=True)
    for target, sources in config['concat_files'].items():
        bld(rule=_concat_task, # FIXME: source=sources,
                target=target, always=True)
